// **********************************************************************
//
// Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.6.2
//
// <auto-generated>
//
// Generated from file `MSK.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __MSK_h__
#define __MSK_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Proxy.h>
#include <Ice/GCObject.h>
#include <Ice/AsyncResult.h>
#include <Ice/Incoming.h>
#include <IceUtil/ScopedArray.h>
#include <IceUtil/Optional.h>
#include <Ice/StreamF.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 306
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 2
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace RoboCompMSKRGBD
{

class MSKRGBDEvent;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::RoboCompMSKRGBD::MSKRGBDEvent>&);
::IceProxy::Ice::Object* upCast(::IceProxy::RoboCompMSKRGBD::MSKRGBDEvent*);

class MSKRGBD;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::RoboCompMSKRGBD::MSKRGBD>&);
::IceProxy::Ice::Object* upCast(::IceProxy::RoboCompMSKRGBD::MSKRGBD*);

}

namespace RoboCompMSKBody
{

class MSKBodyEvent;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::RoboCompMSKBody::MSKBodyEvent>&);
::IceProxy::Ice::Object* upCast(::IceProxy::RoboCompMSKBody::MSKBodyEvent*);

}

namespace RoboCompMSKFace
{

class MSKFaceEvent;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::RoboCompMSKFace::MSKFaceEvent>&);
::IceProxy::Ice::Object* upCast(::IceProxy::RoboCompMSKFace::MSKFaceEvent*);

}

namespace RoboCompMSKASR
{

class MSKASREvent;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::RoboCompMSKASR::MSKASREvent>&);
::IceProxy::Ice::Object* upCast(::IceProxy::RoboCompMSKASR::MSKASREvent*);

class MSKASRConfig;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::RoboCompMSKASR::MSKASRConfig>&);
::IceProxy::Ice::Object* upCast(::IceProxy::RoboCompMSKASR::MSKASRConfig*);

}

}

namespace RoboCompMSKRGBD
{

class MSKRGBDEvent;
::Ice::Object* upCast(::RoboCompMSKRGBD::MSKRGBDEvent*);
typedef ::IceInternal::Handle< ::RoboCompMSKRGBD::MSKRGBDEvent> MSKRGBDEventPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::RoboCompMSKRGBD::MSKRGBDEvent> MSKRGBDEventPrx;
void __patch(MSKRGBDEventPtr&, const ::Ice::ObjectPtr&);

class MSKRGBD;
::Ice::Object* upCast(::RoboCompMSKRGBD::MSKRGBD*);
typedef ::IceInternal::Handle< ::RoboCompMSKRGBD::MSKRGBD> MSKRGBDPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::RoboCompMSKRGBD::MSKRGBD> MSKRGBDPrx;
void __patch(MSKRGBDPtr&, const ::Ice::ObjectPtr&);

}

namespace RoboCompMSKBody
{

class MSKBodyEvent;
::Ice::Object* upCast(::RoboCompMSKBody::MSKBodyEvent*);
typedef ::IceInternal::Handle< ::RoboCompMSKBody::MSKBodyEvent> MSKBodyEventPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::RoboCompMSKBody::MSKBodyEvent> MSKBodyEventPrx;
void __patch(MSKBodyEventPtr&, const ::Ice::ObjectPtr&);

}

namespace RoboCompMSKFace
{

class MSKFaceEvent;
::Ice::Object* upCast(::RoboCompMSKFace::MSKFaceEvent*);
typedef ::IceInternal::Handle< ::RoboCompMSKFace::MSKFaceEvent> MSKFaceEventPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::RoboCompMSKFace::MSKFaceEvent> MSKFaceEventPrx;
void __patch(MSKFaceEventPtr&, const ::Ice::ObjectPtr&);

}

namespace RoboCompMSKASR
{

class MSKASREvent;
::Ice::Object* upCast(::RoboCompMSKASR::MSKASREvent*);
typedef ::IceInternal::Handle< ::RoboCompMSKASR::MSKASREvent> MSKASREventPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::RoboCompMSKASR::MSKASREvent> MSKASREventPrx;
void __patch(MSKASREventPtr&, const ::Ice::ObjectPtr&);

class MSKASRConfig;
::Ice::Object* upCast(::RoboCompMSKASR::MSKASRConfig*);
typedef ::IceInternal::Handle< ::RoboCompMSKASR::MSKASRConfig> MSKASRConfigPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::RoboCompMSKASR::MSKASRConfig> MSKASRConfigPrx;
void __patch(MSKASRConfigPtr&, const ::Ice::ObjectPtr&);

}

namespace RoboCompMSKRGBD
{

typedef ::std::vector< ::Ice::Byte> TRGB;

typedef ::std::vector< ::Ice::Short> TDepth;

struct TRGBImage
{
    ::RoboCompMSKRGBD::TRGB image;
    ::Ice::Int height;
    ::Ice::Int width;
};

struct TDepthImage
{
    ::RoboCompMSKRGBD::TDepth image;
    ::Ice::Int height;
    ::Ice::Int width;
};

}

namespace RoboCompMSKBody
{

enum JointType
{
    SpineBase,
    SpineMid,
    Neck,
    Head,
    ShoulderLeft,
    ElbowLeft,
    WristLeft,
    HandLeft,
    ShoulderRight,
    ElbowRight,
    WristRight,
    HandRight,
    HipLeft,
    KneeLeft,
    AnkleLeft,
    FootLeft,
    HipRight,
    KneeRight,
    AnkleRight,
    FootRight,
    SpineShoulder,
    HandTipLeft,
    ThumbLeft,
    HandTipRight,
    ThumbRight
};

enum stateType
{
    NoTracking,
    Tracking
};

enum JointTrackingState
{
    NotTracked,
    Inferred,
    Tracked
};

struct SkeletonPoint
{
    ::Ice::Float X;
    ::Ice::Float Y;
    ::Ice::Float Z;
};

struct DepthImagePoint
{
    ::Ice::Int X;
    ::Ice::Int Y;
    ::Ice::Int Depth;

    bool operator==(const DepthImagePoint& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(X != __rhs.X)
        {
            return false;
        }
        if(Y != __rhs.Y)
        {
            return false;
        }
        if(Depth != __rhs.Depth)
        {
            return false;
        }
        return true;
    }

    bool operator<(const DepthImagePoint& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(X < __rhs.X)
        {
            return true;
        }
        else if(__rhs.X < X)
        {
            return false;
        }
        if(Y < __rhs.Y)
        {
            return true;
        }
        else if(__rhs.Y < Y)
        {
            return false;
        }
        if(Depth < __rhs.Depth)
        {
            return true;
        }
        else if(__rhs.Depth < Depth)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const DepthImagePoint& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const DepthImagePoint& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const DepthImagePoint& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const DepthImagePoint& __rhs) const
    {
        return !operator<(__rhs);
    }
};

struct ColorImagePoint
{
    ::Ice::Int X;
    ::Ice::Int Y;
    ::Ice::Byte R;
    ::Ice::Byte G;
    ::Ice::Byte B;

    bool operator==(const ColorImagePoint& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(X != __rhs.X)
        {
            return false;
        }
        if(Y != __rhs.Y)
        {
            return false;
        }
        if(R != __rhs.R)
        {
            return false;
        }
        if(G != __rhs.G)
        {
            return false;
        }
        if(B != __rhs.B)
        {
            return false;
        }
        return true;
    }

    bool operator<(const ColorImagePoint& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(X < __rhs.X)
        {
            return true;
        }
        else if(__rhs.X < X)
        {
            return false;
        }
        if(Y < __rhs.Y)
        {
            return true;
        }
        else if(__rhs.Y < Y)
        {
            return false;
        }
        if(R < __rhs.R)
        {
            return true;
        }
        else if(__rhs.R < R)
        {
            return false;
        }
        if(G < __rhs.G)
        {
            return true;
        }
        else if(__rhs.G < G)
        {
            return false;
        }
        if(B < __rhs.B)
        {
            return true;
        }
        else if(__rhs.B < B)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const ColorImagePoint& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const ColorImagePoint& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const ColorImagePoint& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const ColorImagePoint& __rhs) const
    {
        return !operator<(__rhs);
    }
};

struct Joint
{
    ::RoboCompMSKBody::JointTrackingState state;
    ::RoboCompMSKBody::SkeletonPoint Position;
};

typedef ::std::map< ::RoboCompMSKBody::JointType, ::RoboCompMSKBody::Joint> JointList;

struct TPerson
{
    ::RoboCompMSKBody::JointList joints;
    ::RoboCompMSKBody::SkeletonPoint Position;
    ::Ice::Int TrackingId;
    bool trackedState;
};

typedef ::std::map< ::Ice::Int, ::RoboCompMSKBody::TPerson> PersonList;

}

namespace RoboCompMSKFace
{

struct Point3D
{
    ::Ice::Float x;
    ::Ice::Float y;
    ::Ice::Float z;
};

struct DetailedFace
{
    ::RoboCompMSKFace::Point3D nose;
    ::RoboCompMSKFace::Point3D leftEar;
    ::RoboCompMSKFace::Point3D rightEar;
    ::Ice::Int left;
    ::Ice::Int right;
    ::Ice::Int top;
    ::Ice::Int bottom;
    ::Ice::Int identifier;
    bool rightEyeClosed;
    bool leftEyeClosed;
    ::Ice::Float yaw;
    ::Ice::Float pitch;
    ::Ice::Float roll;
    ::RoboCompMSKRGBD::TRGBImage faceImage;
};

typedef ::std::map< ::Ice::Int, ::RoboCompMSKFace::DetailedFace> DetailedFaceMap;

}

namespace RoboCompMSKASR
{

typedef ::std::vector< ::std::string> WordsRecognized;

struct TSentence
{
    ::RoboCompMSKASR::WordsRecognized words;
    ::Ice::Int acquisitionHour;
    ::Ice::Int acquisitionSecs;
    ::Ice::Int acquisitionDay;
    bool blockingCall;
    ::std::string grammarUsed;
};

struct TestConfig
{
    ::std::string testType;
    ::std::string language;
    ::std::string tense;
    ::std::string person;

    bool operator==(const TestConfig& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(testType != __rhs.testType)
        {
            return false;
        }
        if(language != __rhs.language)
        {
            return false;
        }
        if(tense != __rhs.tense)
        {
            return false;
        }
        if(person != __rhs.person)
        {
            return false;
        }
        return true;
    }

    bool operator<(const TestConfig& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(testType < __rhs.testType)
        {
            return true;
        }
        else if(__rhs.testType < testType)
        {
            return false;
        }
        if(language < __rhs.language)
        {
            return true;
        }
        else if(__rhs.language < language)
        {
            return false;
        }
        if(tense < __rhs.tense)
        {
            return true;
        }
        else if(__rhs.tense < tense)
        {
            return false;
        }
        if(person < __rhs.person)
        {
            return true;
        }
        else if(__rhs.person < person)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const TestConfig& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const TestConfig& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const TestConfig& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const TestConfig& __rhs) const
    {
        return !operator<(__rhs);
    }
};

}

namespace Ice
{
template<>
struct StreamableTraits< ::RoboCompMSKRGBD::TRGBImage>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 9;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::RoboCompMSKRGBD::TRGBImage, S>
{
    static void write(S* __os, const ::RoboCompMSKRGBD::TRGBImage& v)
    {
        __os->write(v.image);
        __os->write(v.height);
        __os->write(v.width);
    }
};

template<class S>
struct StreamReader< ::RoboCompMSKRGBD::TRGBImage, S>
{
    static void read(S* __is, ::RoboCompMSKRGBD::TRGBImage& v)
    {
        __is->read(v.image);
        __is->read(v.height);
        __is->read(v.width);
    }
};

template<>
struct StreamableTraits< ::RoboCompMSKRGBD::TDepthImage>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 9;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::RoboCompMSKRGBD::TDepthImage, S>
{
    static void write(S* __os, const ::RoboCompMSKRGBD::TDepthImage& v)
    {
        __os->write(v.image);
        __os->write(v.height);
        __os->write(v.width);
    }
};

template<class S>
struct StreamReader< ::RoboCompMSKRGBD::TDepthImage, S>
{
    static void read(S* __is, ::RoboCompMSKRGBD::TDepthImage& v)
    {
        __is->read(v.image);
        __is->read(v.height);
        __is->read(v.width);
    }
};

}

namespace Ice
{
template<>
struct StreamableTraits< ::RoboCompMSKBody::JointType>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 24;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::RoboCompMSKBody::stateType>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 1;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::RoboCompMSKBody::JointTrackingState>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::RoboCompMSKBody::SkeletonPoint>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 12;
    static const bool fixedLength = true;
};

template<class S>
struct StreamWriter< ::RoboCompMSKBody::SkeletonPoint, S>
{
    static void write(S* __os, const ::RoboCompMSKBody::SkeletonPoint& v)
    {
        __os->write(v.X);
        __os->write(v.Y);
        __os->write(v.Z);
    }
};

template<class S>
struct StreamReader< ::RoboCompMSKBody::SkeletonPoint, S>
{
    static void read(S* __is, ::RoboCompMSKBody::SkeletonPoint& v)
    {
        __is->read(v.X);
        __is->read(v.Y);
        __is->read(v.Z);
    }
};

template<>
struct StreamableTraits< ::RoboCompMSKBody::DepthImagePoint>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 12;
    static const bool fixedLength = true;
};

template<class S>
struct StreamWriter< ::RoboCompMSKBody::DepthImagePoint, S>
{
    static void write(S* __os, const ::RoboCompMSKBody::DepthImagePoint& v)
    {
        __os->write(v.X);
        __os->write(v.Y);
        __os->write(v.Depth);
    }
};

template<class S>
struct StreamReader< ::RoboCompMSKBody::DepthImagePoint, S>
{
    static void read(S* __is, ::RoboCompMSKBody::DepthImagePoint& v)
    {
        __is->read(v.X);
        __is->read(v.Y);
        __is->read(v.Depth);
    }
};

template<>
struct StreamableTraits< ::RoboCompMSKBody::ColorImagePoint>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 11;
    static const bool fixedLength = true;
};

template<class S>
struct StreamWriter< ::RoboCompMSKBody::ColorImagePoint, S>
{
    static void write(S* __os, const ::RoboCompMSKBody::ColorImagePoint& v)
    {
        __os->write(v.X);
        __os->write(v.Y);
        __os->write(v.R);
        __os->write(v.G);
        __os->write(v.B);
    }
};

template<class S>
struct StreamReader< ::RoboCompMSKBody::ColorImagePoint, S>
{
    static void read(S* __is, ::RoboCompMSKBody::ColorImagePoint& v)
    {
        __is->read(v.X);
        __is->read(v.Y);
        __is->read(v.R);
        __is->read(v.G);
        __is->read(v.B);
    }
};

template<>
struct StreamableTraits< ::RoboCompMSKBody::Joint>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 13;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::RoboCompMSKBody::Joint, S>
{
    static void write(S* __os, const ::RoboCompMSKBody::Joint& v)
    {
        __os->write(v.state);
        __os->write(v.Position);
    }
};

template<class S>
struct StreamReader< ::RoboCompMSKBody::Joint, S>
{
    static void read(S* __is, ::RoboCompMSKBody::Joint& v)
    {
        __is->read(v.state);
        __is->read(v.Position);
    }
};

template<>
struct StreamableTraits< ::RoboCompMSKBody::TPerson>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 18;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::RoboCompMSKBody::TPerson, S>
{
    static void write(S* __os, const ::RoboCompMSKBody::TPerson& v)
    {
        __os->write(v.joints);
        __os->write(v.Position);
        __os->write(v.TrackingId);
        __os->write(v.trackedState);
    }
};

template<class S>
struct StreamReader< ::RoboCompMSKBody::TPerson, S>
{
    static void read(S* __is, ::RoboCompMSKBody::TPerson& v)
    {
        __is->read(v.joints);
        __is->read(v.Position);
        __is->read(v.TrackingId);
        __is->read(v.trackedState);
    }
};

}

namespace Ice
{
template<>
struct StreamableTraits< ::RoboCompMSKFace::Point3D>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 12;
    static const bool fixedLength = true;
};

template<class S>
struct StreamWriter< ::RoboCompMSKFace::Point3D, S>
{
    static void write(S* __os, const ::RoboCompMSKFace::Point3D& v)
    {
        __os->write(v.x);
        __os->write(v.y);
        __os->write(v.z);
    }
};

template<class S>
struct StreamReader< ::RoboCompMSKFace::Point3D, S>
{
    static void read(S* __is, ::RoboCompMSKFace::Point3D& v)
    {
        __is->read(v.x);
        __is->read(v.y);
        __is->read(v.z);
    }
};

template<>
struct StreamableTraits< ::RoboCompMSKFace::DetailedFace>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 79;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::RoboCompMSKFace::DetailedFace, S>
{
    static void write(S* __os, const ::RoboCompMSKFace::DetailedFace& v)
    {
        __os->write(v.nose);
        __os->write(v.leftEar);
        __os->write(v.rightEar);
        __os->write(v.left);
        __os->write(v.right);
        __os->write(v.top);
        __os->write(v.bottom);
        __os->write(v.identifier);
        __os->write(v.rightEyeClosed);
        __os->write(v.leftEyeClosed);
        __os->write(v.yaw);
        __os->write(v.pitch);
        __os->write(v.roll);
        __os->write(v.faceImage);
    }
};

template<class S>
struct StreamReader< ::RoboCompMSKFace::DetailedFace, S>
{
    static void read(S* __is, ::RoboCompMSKFace::DetailedFace& v)
    {
        __is->read(v.nose);
        __is->read(v.leftEar);
        __is->read(v.rightEar);
        __is->read(v.left);
        __is->read(v.right);
        __is->read(v.top);
        __is->read(v.bottom);
        __is->read(v.identifier);
        __is->read(v.rightEyeClosed);
        __is->read(v.leftEyeClosed);
        __is->read(v.yaw);
        __is->read(v.pitch);
        __is->read(v.roll);
        __is->read(v.faceImage);
    }
};

}

namespace Ice
{
template<>
struct StreamableTraits< ::RoboCompMSKASR::TSentence>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 15;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::RoboCompMSKASR::TSentence, S>
{
    static void write(S* __os, const ::RoboCompMSKASR::TSentence& v)
    {
        __os->write(v.words);
        __os->write(v.acquisitionHour);
        __os->write(v.acquisitionSecs);
        __os->write(v.acquisitionDay);
        __os->write(v.blockingCall);
        __os->write(v.grammarUsed);
    }
};

template<class S>
struct StreamReader< ::RoboCompMSKASR::TSentence, S>
{
    static void read(S* __is, ::RoboCompMSKASR::TSentence& v)
    {
        __is->read(v.words);
        __is->read(v.acquisitionHour);
        __is->read(v.acquisitionSecs);
        __is->read(v.acquisitionDay);
        __is->read(v.blockingCall);
        __is->read(v.grammarUsed);
    }
};

template<>
struct StreamableTraits< ::RoboCompMSKASR::TestConfig>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::RoboCompMSKASR::TestConfig, S>
{
    static void write(S* __os, const ::RoboCompMSKASR::TestConfig& v)
    {
        __os->write(v.testType);
        __os->write(v.language);
        __os->write(v.tense);
        __os->write(v.person);
    }
};

template<class S>
struct StreamReader< ::RoboCompMSKASR::TestConfig, S>
{
    static void read(S* __is, ::RoboCompMSKASR::TestConfig& v)
    {
        __is->read(v.testType);
        __is->read(v.language);
        __is->read(v.tense);
        __is->read(v.person);
    }
};

}

namespace RoboCompMSKRGBD
{

class Callback_MSKRGBDEvent_newRGBImageAvailable_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MSKRGBDEvent_newRGBImageAvailable_Base> Callback_MSKRGBDEvent_newRGBImageAvailablePtr;

class Callback_MSKRGBDEvent_newDepthImageAvailable_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MSKRGBDEvent_newDepthImageAvailable_Base> Callback_MSKRGBDEvent_newDepthImageAvailablePtr;

class Callback_MSKRGBD_getRGBImage_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MSKRGBD_getRGBImage_Base> Callback_MSKRGBD_getRGBImagePtr;

class Callback_MSKRGBD_getDepthImage_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MSKRGBD_getDepthImage_Base> Callback_MSKRGBD_getDepthImagePtr;

}

namespace RoboCompMSKBody
{

class Callback_MSKBodyEvent_newMSKBodyEvent_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MSKBodyEvent_newMSKBodyEvent_Base> Callback_MSKBodyEvent_newMSKBodyEventPtr;

}

namespace RoboCompMSKFace
{

class Callback_MSKFaceEvent_newFaceAvailable_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MSKFaceEvent_newFaceAvailable_Base> Callback_MSKFaceEvent_newFaceAvailablePtr;

}

namespace RoboCompMSKASR
{

class Callback_MSKASREvent_newSentenceAvailable_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MSKASREvent_newSentenceAvailable_Base> Callback_MSKASREvent_newSentenceAvailablePtr;

class Callback_MSKASRConfig_setTestConfig_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MSKASRConfig_setTestConfig_Base> Callback_MSKASRConfig_setTestConfigPtr;

class Callback_MSKASRConfig_setTestQuestion_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MSKASRConfig_setTestQuestion_Base> Callback_MSKASRConfig_setTestQuestionPtr;

}

namespace IceProxy
{

namespace RoboCompMSKRGBD
{

class MSKRGBDEvent : virtual public ::IceProxy::Ice::Object
{
public:

    void newRGBImageAvailable(const ::RoboCompMSKRGBD::TRGBImage& __p_RGBImage)
    {
        newRGBImageAvailable(__p_RGBImage, 0);
    }
    void newRGBImageAvailable(const ::RoboCompMSKRGBD::TRGBImage& __p_RGBImage, const ::Ice::Context& __ctx)
    {
        newRGBImageAvailable(__p_RGBImage, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_newRGBImageAvailable(const ::RoboCompMSKRGBD::TRGBImage& __p_RGBImage, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_newRGBImageAvailable(__p_RGBImage, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_newRGBImageAvailable(const ::RoboCompMSKRGBD::TRGBImage& __p_RGBImage, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_newRGBImageAvailable(__p_RGBImage, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_newRGBImageAvailable(const ::RoboCompMSKRGBD::TRGBImage& __p_RGBImage, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_newRGBImageAvailable(__p_RGBImage, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_newRGBImageAvailable(const ::RoboCompMSKRGBD::TRGBImage& __p_RGBImage, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_newRGBImageAvailable(__p_RGBImage, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_newRGBImageAvailable(const ::RoboCompMSKRGBD::TRGBImage& __p_RGBImage)
    {
        return begin_newRGBImageAvailable(__p_RGBImage, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_newRGBImageAvailable(const ::RoboCompMSKRGBD::TRGBImage& __p_RGBImage, const ::Ice::Context& __ctx)
    {
        return begin_newRGBImageAvailable(__p_RGBImage, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_newRGBImageAvailable(const ::RoboCompMSKRGBD::TRGBImage& __p_RGBImage, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_newRGBImageAvailable(__p_RGBImage, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_newRGBImageAvailable(const ::RoboCompMSKRGBD::TRGBImage& __p_RGBImage, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_newRGBImageAvailable(__p_RGBImage, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_newRGBImageAvailable(const ::RoboCompMSKRGBD::TRGBImage& __p_RGBImage, const ::RoboCompMSKRGBD::Callback_MSKRGBDEvent_newRGBImageAvailablePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_newRGBImageAvailable(__p_RGBImage, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_newRGBImageAvailable(const ::RoboCompMSKRGBD::TRGBImage& __p_RGBImage, const ::Ice::Context& __ctx, const ::RoboCompMSKRGBD::Callback_MSKRGBDEvent_newRGBImageAvailablePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_newRGBImageAvailable(__p_RGBImage, &__ctx, __del, __cookie);
    }

    void end_newRGBImageAvailable(const ::Ice::AsyncResultPtr&);
    
private:

    void newRGBImageAvailable(const ::RoboCompMSKRGBD::TRGBImage&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_newRGBImageAvailable(const ::RoboCompMSKRGBD::TRGBImage&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void newDepthImageAvailable(const ::RoboCompMSKRGBD::TDepthImage& __p_depthImage)
    {
        newDepthImageAvailable(__p_depthImage, 0);
    }
    void newDepthImageAvailable(const ::RoboCompMSKRGBD::TDepthImage& __p_depthImage, const ::Ice::Context& __ctx)
    {
        newDepthImageAvailable(__p_depthImage, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_newDepthImageAvailable(const ::RoboCompMSKRGBD::TDepthImage& __p_depthImage, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_newDepthImageAvailable(__p_depthImage, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_newDepthImageAvailable(const ::RoboCompMSKRGBD::TDepthImage& __p_depthImage, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_newDepthImageAvailable(__p_depthImage, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_newDepthImageAvailable(const ::RoboCompMSKRGBD::TDepthImage& __p_depthImage, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_newDepthImageAvailable(__p_depthImage, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_newDepthImageAvailable(const ::RoboCompMSKRGBD::TDepthImage& __p_depthImage, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_newDepthImageAvailable(__p_depthImage, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_newDepthImageAvailable(const ::RoboCompMSKRGBD::TDepthImage& __p_depthImage)
    {
        return begin_newDepthImageAvailable(__p_depthImage, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_newDepthImageAvailable(const ::RoboCompMSKRGBD::TDepthImage& __p_depthImage, const ::Ice::Context& __ctx)
    {
        return begin_newDepthImageAvailable(__p_depthImage, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_newDepthImageAvailable(const ::RoboCompMSKRGBD::TDepthImage& __p_depthImage, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_newDepthImageAvailable(__p_depthImage, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_newDepthImageAvailable(const ::RoboCompMSKRGBD::TDepthImage& __p_depthImage, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_newDepthImageAvailable(__p_depthImage, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_newDepthImageAvailable(const ::RoboCompMSKRGBD::TDepthImage& __p_depthImage, const ::RoboCompMSKRGBD::Callback_MSKRGBDEvent_newDepthImageAvailablePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_newDepthImageAvailable(__p_depthImage, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_newDepthImageAvailable(const ::RoboCompMSKRGBD::TDepthImage& __p_depthImage, const ::Ice::Context& __ctx, const ::RoboCompMSKRGBD::Callback_MSKRGBDEvent_newDepthImageAvailablePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_newDepthImageAvailable(__p_depthImage, &__ctx, __del, __cookie);
    }

    void end_newDepthImageAvailable(const ::Ice::AsyncResultPtr&);
    
private:

    void newDepthImageAvailable(const ::RoboCompMSKRGBD::TDepthImage&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_newDepthImageAvailable(const ::RoboCompMSKRGBD::TDepthImage&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<MSKRGBDEvent> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<MSKRGBDEvent*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBDEvent> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<MSKRGBDEvent*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBDEvent> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<MSKRGBDEvent*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBDEvent> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<MSKRGBDEvent*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBDEvent> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<MSKRGBDEvent*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBDEvent> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<MSKRGBDEvent*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBDEvent> ice_secure(bool __secure) const
    {
        return dynamic_cast<MSKRGBDEvent*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBDEvent> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<MSKRGBDEvent*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBDEvent> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<MSKRGBDEvent*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBDEvent> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<MSKRGBDEvent*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBDEvent> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<MSKRGBDEvent*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBDEvent> ice_invocationTimeout(int __timeout) const
    {
        return dynamic_cast<MSKRGBDEvent*>(::IceProxy::Ice::Object::ice_invocationTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBDEvent> ice_twoway() const
    {
        return dynamic_cast<MSKRGBDEvent*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBDEvent> ice_oneway() const
    {
        return dynamic_cast<MSKRGBDEvent*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBDEvent> ice_batchOneway() const
    {
        return dynamic_cast<MSKRGBDEvent*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBDEvent> ice_datagram() const
    {
        return dynamic_cast<MSKRGBDEvent*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBDEvent> ice_batchDatagram() const
    {
        return dynamic_cast<MSKRGBDEvent*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBDEvent> ice_compress(bool __compress) const
    {
        return dynamic_cast<MSKRGBDEvent*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBDEvent> ice_timeout(int __timeout) const
    {
        return dynamic_cast<MSKRGBDEvent*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBDEvent> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<MSKRGBDEvent*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBDEvent> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<MSKRGBDEvent*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class MSKRGBD : virtual public ::IceProxy::Ice::Object
{
public:

    void getRGBImage(::RoboCompMSKRGBD::TRGBImage& __p_RGBImage)
    {
        getRGBImage(__p_RGBImage, 0);
    }
    void getRGBImage(::RoboCompMSKRGBD::TRGBImage& __p_RGBImage, const ::Ice::Context& __ctx)
    {
        getRGBImage(__p_RGBImage, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getRGBImage(const ::IceInternal::Function<void (const ::RoboCompMSKRGBD::TRGBImage&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getRGBImage(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getRGBImage(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getRGBImage(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getRGBImage(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::RoboCompMSKRGBD::TRGBImage&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getRGBImage(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getRGBImage(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getRGBImage(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getRGBImage(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::RoboCompMSKRGBD::TRGBImage&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getRGBImage()
    {
        return begin_getRGBImage(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRGBImage(const ::Ice::Context& __ctx)
    {
        return begin_getRGBImage(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRGBImage(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRGBImage(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRGBImage(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRGBImage(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRGBImage(const ::RoboCompMSKRGBD::Callback_MSKRGBD_getRGBImagePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRGBImage(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRGBImage(const ::Ice::Context& __ctx, const ::RoboCompMSKRGBD::Callback_MSKRGBD_getRGBImagePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRGBImage(&__ctx, __del, __cookie);
    }

    void end_getRGBImage(::RoboCompMSKRGBD::TRGBImage& __p_RGBImage, const ::Ice::AsyncResultPtr&);
    
private:

    void getRGBImage(::RoboCompMSKRGBD::TRGBImage&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getRGBImage(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void getDepthImage(::RoboCompMSKRGBD::TDepthImage& __p_depthImage)
    {
        getDepthImage(__p_depthImage, 0);
    }
    void getDepthImage(::RoboCompMSKRGBD::TDepthImage& __p_depthImage, const ::Ice::Context& __ctx)
    {
        getDepthImage(__p_depthImage, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getDepthImage(const ::IceInternal::Function<void (const ::RoboCompMSKRGBD::TDepthImage&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getDepthImage(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getDepthImage(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getDepthImage(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getDepthImage(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::RoboCompMSKRGBD::TDepthImage&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getDepthImage(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getDepthImage(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getDepthImage(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getDepthImage(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::RoboCompMSKRGBD::TDepthImage&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getDepthImage()
    {
        return begin_getDepthImage(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getDepthImage(const ::Ice::Context& __ctx)
    {
        return begin_getDepthImage(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getDepthImage(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDepthImage(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDepthImage(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDepthImage(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDepthImage(const ::RoboCompMSKRGBD::Callback_MSKRGBD_getDepthImagePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDepthImage(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getDepthImage(const ::Ice::Context& __ctx, const ::RoboCompMSKRGBD::Callback_MSKRGBD_getDepthImagePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getDepthImage(&__ctx, __del, __cookie);
    }

    void end_getDepthImage(::RoboCompMSKRGBD::TDepthImage& __p_depthImage, const ::Ice::AsyncResultPtr&);
    
private:

    void getDepthImage(::RoboCompMSKRGBD::TDepthImage&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getDepthImage(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<MSKRGBD> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<MSKRGBD*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBD> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<MSKRGBD*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBD> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<MSKRGBD*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBD> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<MSKRGBD*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBD> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<MSKRGBD*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBD> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<MSKRGBD*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBD> ice_secure(bool __secure) const
    {
        return dynamic_cast<MSKRGBD*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBD> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<MSKRGBD*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBD> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<MSKRGBD*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBD> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<MSKRGBD*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBD> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<MSKRGBD*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBD> ice_invocationTimeout(int __timeout) const
    {
        return dynamic_cast<MSKRGBD*>(::IceProxy::Ice::Object::ice_invocationTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBD> ice_twoway() const
    {
        return dynamic_cast<MSKRGBD*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBD> ice_oneway() const
    {
        return dynamic_cast<MSKRGBD*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBD> ice_batchOneway() const
    {
        return dynamic_cast<MSKRGBD*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBD> ice_datagram() const
    {
        return dynamic_cast<MSKRGBD*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBD> ice_batchDatagram() const
    {
        return dynamic_cast<MSKRGBD*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBD> ice_compress(bool __compress) const
    {
        return dynamic_cast<MSKRGBD*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBD> ice_timeout(int __timeout) const
    {
        return dynamic_cast<MSKRGBD*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBD> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<MSKRGBD*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<MSKRGBD> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<MSKRGBD*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

namespace RoboCompMSKBody
{

class MSKBodyEvent : virtual public ::IceProxy::Ice::Object
{
public:

    void newMSKBodyEvent(const ::RoboCompMSKBody::PersonList& __p_people, ::Ice::Long __p_timestamp)
    {
        newMSKBodyEvent(__p_people, __p_timestamp, 0);
    }
    void newMSKBodyEvent(const ::RoboCompMSKBody::PersonList& __p_people, ::Ice::Long __p_timestamp, const ::Ice::Context& __ctx)
    {
        newMSKBodyEvent(__p_people, __p_timestamp, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_newMSKBodyEvent(const ::RoboCompMSKBody::PersonList& __p_people, ::Ice::Long __p_timestamp, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_newMSKBodyEvent(__p_people, __p_timestamp, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_newMSKBodyEvent(const ::RoboCompMSKBody::PersonList& __p_people, ::Ice::Long __p_timestamp, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_newMSKBodyEvent(__p_people, __p_timestamp, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_newMSKBodyEvent(const ::RoboCompMSKBody::PersonList& __p_people, ::Ice::Long __p_timestamp, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_newMSKBodyEvent(__p_people, __p_timestamp, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_newMSKBodyEvent(const ::RoboCompMSKBody::PersonList& __p_people, ::Ice::Long __p_timestamp, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_newMSKBodyEvent(__p_people, __p_timestamp, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_newMSKBodyEvent(const ::RoboCompMSKBody::PersonList& __p_people, ::Ice::Long __p_timestamp)
    {
        return begin_newMSKBodyEvent(__p_people, __p_timestamp, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_newMSKBodyEvent(const ::RoboCompMSKBody::PersonList& __p_people, ::Ice::Long __p_timestamp, const ::Ice::Context& __ctx)
    {
        return begin_newMSKBodyEvent(__p_people, __p_timestamp, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_newMSKBodyEvent(const ::RoboCompMSKBody::PersonList& __p_people, ::Ice::Long __p_timestamp, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_newMSKBodyEvent(__p_people, __p_timestamp, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_newMSKBodyEvent(const ::RoboCompMSKBody::PersonList& __p_people, ::Ice::Long __p_timestamp, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_newMSKBodyEvent(__p_people, __p_timestamp, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_newMSKBodyEvent(const ::RoboCompMSKBody::PersonList& __p_people, ::Ice::Long __p_timestamp, const ::RoboCompMSKBody::Callback_MSKBodyEvent_newMSKBodyEventPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_newMSKBodyEvent(__p_people, __p_timestamp, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_newMSKBodyEvent(const ::RoboCompMSKBody::PersonList& __p_people, ::Ice::Long __p_timestamp, const ::Ice::Context& __ctx, const ::RoboCompMSKBody::Callback_MSKBodyEvent_newMSKBodyEventPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_newMSKBodyEvent(__p_people, __p_timestamp, &__ctx, __del, __cookie);
    }

    void end_newMSKBodyEvent(const ::Ice::AsyncResultPtr&);
    
private:

    void newMSKBodyEvent(const ::RoboCompMSKBody::PersonList&, ::Ice::Long, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_newMSKBodyEvent(const ::RoboCompMSKBody::PersonList&, ::Ice::Long, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<MSKBodyEvent> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<MSKBodyEvent*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<MSKBodyEvent> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<MSKBodyEvent*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<MSKBodyEvent> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<MSKBodyEvent*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<MSKBodyEvent> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<MSKBodyEvent*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<MSKBodyEvent> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<MSKBodyEvent*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<MSKBodyEvent> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<MSKBodyEvent*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<MSKBodyEvent> ice_secure(bool __secure) const
    {
        return dynamic_cast<MSKBodyEvent*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<MSKBodyEvent> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<MSKBodyEvent*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<MSKBodyEvent> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<MSKBodyEvent*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<MSKBodyEvent> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<MSKBodyEvent*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<MSKBodyEvent> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<MSKBodyEvent*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<MSKBodyEvent> ice_invocationTimeout(int __timeout) const
    {
        return dynamic_cast<MSKBodyEvent*>(::IceProxy::Ice::Object::ice_invocationTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<MSKBodyEvent> ice_twoway() const
    {
        return dynamic_cast<MSKBodyEvent*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<MSKBodyEvent> ice_oneway() const
    {
        return dynamic_cast<MSKBodyEvent*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<MSKBodyEvent> ice_batchOneway() const
    {
        return dynamic_cast<MSKBodyEvent*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<MSKBodyEvent> ice_datagram() const
    {
        return dynamic_cast<MSKBodyEvent*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<MSKBodyEvent> ice_batchDatagram() const
    {
        return dynamic_cast<MSKBodyEvent*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<MSKBodyEvent> ice_compress(bool __compress) const
    {
        return dynamic_cast<MSKBodyEvent*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<MSKBodyEvent> ice_timeout(int __timeout) const
    {
        return dynamic_cast<MSKBodyEvent*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<MSKBodyEvent> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<MSKBodyEvent*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<MSKBodyEvent> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<MSKBodyEvent*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

namespace RoboCompMSKFace
{

class MSKFaceEvent : virtual public ::IceProxy::Ice::Object
{
public:

    void newFaceAvailable(const ::RoboCompMSKFace::DetailedFaceMap& __p_face, ::Ice::Long __p_timestamp)
    {
        newFaceAvailable(__p_face, __p_timestamp, 0);
    }
    void newFaceAvailable(const ::RoboCompMSKFace::DetailedFaceMap& __p_face, ::Ice::Long __p_timestamp, const ::Ice::Context& __ctx)
    {
        newFaceAvailable(__p_face, __p_timestamp, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_newFaceAvailable(const ::RoboCompMSKFace::DetailedFaceMap& __p_face, ::Ice::Long __p_timestamp, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_newFaceAvailable(__p_face, __p_timestamp, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_newFaceAvailable(const ::RoboCompMSKFace::DetailedFaceMap& __p_face, ::Ice::Long __p_timestamp, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_newFaceAvailable(__p_face, __p_timestamp, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_newFaceAvailable(const ::RoboCompMSKFace::DetailedFaceMap& __p_face, ::Ice::Long __p_timestamp, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_newFaceAvailable(__p_face, __p_timestamp, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_newFaceAvailable(const ::RoboCompMSKFace::DetailedFaceMap& __p_face, ::Ice::Long __p_timestamp, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_newFaceAvailable(__p_face, __p_timestamp, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_newFaceAvailable(const ::RoboCompMSKFace::DetailedFaceMap& __p_face, ::Ice::Long __p_timestamp)
    {
        return begin_newFaceAvailable(__p_face, __p_timestamp, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_newFaceAvailable(const ::RoboCompMSKFace::DetailedFaceMap& __p_face, ::Ice::Long __p_timestamp, const ::Ice::Context& __ctx)
    {
        return begin_newFaceAvailable(__p_face, __p_timestamp, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_newFaceAvailable(const ::RoboCompMSKFace::DetailedFaceMap& __p_face, ::Ice::Long __p_timestamp, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_newFaceAvailable(__p_face, __p_timestamp, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_newFaceAvailable(const ::RoboCompMSKFace::DetailedFaceMap& __p_face, ::Ice::Long __p_timestamp, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_newFaceAvailable(__p_face, __p_timestamp, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_newFaceAvailable(const ::RoboCompMSKFace::DetailedFaceMap& __p_face, ::Ice::Long __p_timestamp, const ::RoboCompMSKFace::Callback_MSKFaceEvent_newFaceAvailablePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_newFaceAvailable(__p_face, __p_timestamp, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_newFaceAvailable(const ::RoboCompMSKFace::DetailedFaceMap& __p_face, ::Ice::Long __p_timestamp, const ::Ice::Context& __ctx, const ::RoboCompMSKFace::Callback_MSKFaceEvent_newFaceAvailablePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_newFaceAvailable(__p_face, __p_timestamp, &__ctx, __del, __cookie);
    }

    void end_newFaceAvailable(const ::Ice::AsyncResultPtr&);
    
private:

    void newFaceAvailable(const ::RoboCompMSKFace::DetailedFaceMap&, ::Ice::Long, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_newFaceAvailable(const ::RoboCompMSKFace::DetailedFaceMap&, ::Ice::Long, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<MSKFaceEvent> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<MSKFaceEvent*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<MSKFaceEvent> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<MSKFaceEvent*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<MSKFaceEvent> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<MSKFaceEvent*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<MSKFaceEvent> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<MSKFaceEvent*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<MSKFaceEvent> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<MSKFaceEvent*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<MSKFaceEvent> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<MSKFaceEvent*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<MSKFaceEvent> ice_secure(bool __secure) const
    {
        return dynamic_cast<MSKFaceEvent*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<MSKFaceEvent> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<MSKFaceEvent*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<MSKFaceEvent> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<MSKFaceEvent*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<MSKFaceEvent> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<MSKFaceEvent*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<MSKFaceEvent> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<MSKFaceEvent*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<MSKFaceEvent> ice_invocationTimeout(int __timeout) const
    {
        return dynamic_cast<MSKFaceEvent*>(::IceProxy::Ice::Object::ice_invocationTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<MSKFaceEvent> ice_twoway() const
    {
        return dynamic_cast<MSKFaceEvent*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<MSKFaceEvent> ice_oneway() const
    {
        return dynamic_cast<MSKFaceEvent*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<MSKFaceEvent> ice_batchOneway() const
    {
        return dynamic_cast<MSKFaceEvent*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<MSKFaceEvent> ice_datagram() const
    {
        return dynamic_cast<MSKFaceEvent*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<MSKFaceEvent> ice_batchDatagram() const
    {
        return dynamic_cast<MSKFaceEvent*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<MSKFaceEvent> ice_compress(bool __compress) const
    {
        return dynamic_cast<MSKFaceEvent*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<MSKFaceEvent> ice_timeout(int __timeout) const
    {
        return dynamic_cast<MSKFaceEvent*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<MSKFaceEvent> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<MSKFaceEvent*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<MSKFaceEvent> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<MSKFaceEvent*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

namespace RoboCompMSKASR
{

class MSKASREvent : virtual public ::IceProxy::Ice::Object
{
public:

    void newSentenceAvailable(const ::RoboCompMSKASR::TSentence& __p_sentence)
    {
        newSentenceAvailable(__p_sentence, 0);
    }
    void newSentenceAvailable(const ::RoboCompMSKASR::TSentence& __p_sentence, const ::Ice::Context& __ctx)
    {
        newSentenceAvailable(__p_sentence, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_newSentenceAvailable(const ::RoboCompMSKASR::TSentence& __p_sentence, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_newSentenceAvailable(__p_sentence, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_newSentenceAvailable(const ::RoboCompMSKASR::TSentence& __p_sentence, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_newSentenceAvailable(__p_sentence, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_newSentenceAvailable(const ::RoboCompMSKASR::TSentence& __p_sentence, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_newSentenceAvailable(__p_sentence, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_newSentenceAvailable(const ::RoboCompMSKASR::TSentence& __p_sentence, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_newSentenceAvailable(__p_sentence, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_newSentenceAvailable(const ::RoboCompMSKASR::TSentence& __p_sentence)
    {
        return begin_newSentenceAvailable(__p_sentence, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_newSentenceAvailable(const ::RoboCompMSKASR::TSentence& __p_sentence, const ::Ice::Context& __ctx)
    {
        return begin_newSentenceAvailable(__p_sentence, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_newSentenceAvailable(const ::RoboCompMSKASR::TSentence& __p_sentence, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_newSentenceAvailable(__p_sentence, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_newSentenceAvailable(const ::RoboCompMSKASR::TSentence& __p_sentence, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_newSentenceAvailable(__p_sentence, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_newSentenceAvailable(const ::RoboCompMSKASR::TSentence& __p_sentence, const ::RoboCompMSKASR::Callback_MSKASREvent_newSentenceAvailablePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_newSentenceAvailable(__p_sentence, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_newSentenceAvailable(const ::RoboCompMSKASR::TSentence& __p_sentence, const ::Ice::Context& __ctx, const ::RoboCompMSKASR::Callback_MSKASREvent_newSentenceAvailablePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_newSentenceAvailable(__p_sentence, &__ctx, __del, __cookie);
    }

    void end_newSentenceAvailable(const ::Ice::AsyncResultPtr&);
    
private:

    void newSentenceAvailable(const ::RoboCompMSKASR::TSentence&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_newSentenceAvailable(const ::RoboCompMSKASR::TSentence&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<MSKASREvent> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<MSKASREvent*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<MSKASREvent> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<MSKASREvent*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<MSKASREvent> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<MSKASREvent*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<MSKASREvent> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<MSKASREvent*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<MSKASREvent> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<MSKASREvent*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<MSKASREvent> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<MSKASREvent*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<MSKASREvent> ice_secure(bool __secure) const
    {
        return dynamic_cast<MSKASREvent*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<MSKASREvent> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<MSKASREvent*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<MSKASREvent> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<MSKASREvent*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<MSKASREvent> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<MSKASREvent*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<MSKASREvent> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<MSKASREvent*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<MSKASREvent> ice_invocationTimeout(int __timeout) const
    {
        return dynamic_cast<MSKASREvent*>(::IceProxy::Ice::Object::ice_invocationTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<MSKASREvent> ice_twoway() const
    {
        return dynamic_cast<MSKASREvent*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<MSKASREvent> ice_oneway() const
    {
        return dynamic_cast<MSKASREvent*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<MSKASREvent> ice_batchOneway() const
    {
        return dynamic_cast<MSKASREvent*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<MSKASREvent> ice_datagram() const
    {
        return dynamic_cast<MSKASREvent*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<MSKASREvent> ice_batchDatagram() const
    {
        return dynamic_cast<MSKASREvent*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<MSKASREvent> ice_compress(bool __compress) const
    {
        return dynamic_cast<MSKASREvent*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<MSKASREvent> ice_timeout(int __timeout) const
    {
        return dynamic_cast<MSKASREvent*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<MSKASREvent> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<MSKASREvent*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<MSKASREvent> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<MSKASREvent*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class MSKASRConfig : virtual public ::IceProxy::Ice::Object
{
public:

    void setTestConfig(const ::RoboCompMSKASR::TestConfig& __p_config)
    {
        setTestConfig(__p_config, 0);
    }
    void setTestConfig(const ::RoboCompMSKASR::TestConfig& __p_config, const ::Ice::Context& __ctx)
    {
        setTestConfig(__p_config, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_setTestConfig(const ::RoboCompMSKASR::TestConfig& __p_config, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_setTestConfig(__p_config, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_setTestConfig(const ::RoboCompMSKASR::TestConfig& __p_config, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setTestConfig(__p_config, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_setTestConfig(const ::RoboCompMSKASR::TestConfig& __p_config, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_setTestConfig(__p_config, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_setTestConfig(const ::RoboCompMSKASR::TestConfig& __p_config, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setTestConfig(__p_config, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_setTestConfig(const ::RoboCompMSKASR::TestConfig& __p_config)
    {
        return begin_setTestConfig(__p_config, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setTestConfig(const ::RoboCompMSKASR::TestConfig& __p_config, const ::Ice::Context& __ctx)
    {
        return begin_setTestConfig(__p_config, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setTestConfig(const ::RoboCompMSKASR::TestConfig& __p_config, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTestConfig(__p_config, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setTestConfig(const ::RoboCompMSKASR::TestConfig& __p_config, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTestConfig(__p_config, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setTestConfig(const ::RoboCompMSKASR::TestConfig& __p_config, const ::RoboCompMSKASR::Callback_MSKASRConfig_setTestConfigPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTestConfig(__p_config, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setTestConfig(const ::RoboCompMSKASR::TestConfig& __p_config, const ::Ice::Context& __ctx, const ::RoboCompMSKASR::Callback_MSKASRConfig_setTestConfigPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTestConfig(__p_config, &__ctx, __del, __cookie);
    }

    void end_setTestConfig(const ::Ice::AsyncResultPtr&);
    
private:

    void setTestConfig(const ::RoboCompMSKASR::TestConfig&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setTestConfig(const ::RoboCompMSKASR::TestConfig&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setTestQuestion(::Ice::Int __p_questionNumber)
    {
        setTestQuestion(__p_questionNumber, 0);
    }
    void setTestQuestion(::Ice::Int __p_questionNumber, const ::Ice::Context& __ctx)
    {
        setTestQuestion(__p_questionNumber, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_setTestQuestion(::Ice::Int __p_questionNumber, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_setTestQuestion(__p_questionNumber, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_setTestQuestion(::Ice::Int __p_questionNumber, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setTestQuestion(__p_questionNumber, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_setTestQuestion(::Ice::Int __p_questionNumber, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_setTestQuestion(__p_questionNumber, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_setTestQuestion(::Ice::Int __p_questionNumber, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setTestQuestion(__p_questionNumber, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_setTestQuestion(::Ice::Int __p_questionNumber)
    {
        return begin_setTestQuestion(__p_questionNumber, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setTestQuestion(::Ice::Int __p_questionNumber, const ::Ice::Context& __ctx)
    {
        return begin_setTestQuestion(__p_questionNumber, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setTestQuestion(::Ice::Int __p_questionNumber, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTestQuestion(__p_questionNumber, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setTestQuestion(::Ice::Int __p_questionNumber, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTestQuestion(__p_questionNumber, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setTestQuestion(::Ice::Int __p_questionNumber, const ::RoboCompMSKASR::Callback_MSKASRConfig_setTestQuestionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTestQuestion(__p_questionNumber, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setTestQuestion(::Ice::Int __p_questionNumber, const ::Ice::Context& __ctx, const ::RoboCompMSKASR::Callback_MSKASRConfig_setTestQuestionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setTestQuestion(__p_questionNumber, &__ctx, __del, __cookie);
    }

    void end_setTestQuestion(const ::Ice::AsyncResultPtr&);
    
private:

    void setTestQuestion(::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setTestQuestion(::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<MSKASRConfig> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<MSKASRConfig*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<MSKASRConfig> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<MSKASRConfig*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<MSKASRConfig> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<MSKASRConfig*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<MSKASRConfig> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<MSKASRConfig*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<MSKASRConfig> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<MSKASRConfig*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<MSKASRConfig> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<MSKASRConfig*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<MSKASRConfig> ice_secure(bool __secure) const
    {
        return dynamic_cast<MSKASRConfig*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<MSKASRConfig> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<MSKASRConfig*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<MSKASRConfig> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<MSKASRConfig*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<MSKASRConfig> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<MSKASRConfig*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<MSKASRConfig> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<MSKASRConfig*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<MSKASRConfig> ice_invocationTimeout(int __timeout) const
    {
        return dynamic_cast<MSKASRConfig*>(::IceProxy::Ice::Object::ice_invocationTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<MSKASRConfig> ice_twoway() const
    {
        return dynamic_cast<MSKASRConfig*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<MSKASRConfig> ice_oneway() const
    {
        return dynamic_cast<MSKASRConfig*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<MSKASRConfig> ice_batchOneway() const
    {
        return dynamic_cast<MSKASRConfig*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<MSKASRConfig> ice_datagram() const
    {
        return dynamic_cast<MSKASRConfig*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<MSKASRConfig> ice_batchDatagram() const
    {
        return dynamic_cast<MSKASRConfig*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<MSKASRConfig> ice_compress(bool __compress) const
    {
        return dynamic_cast<MSKASRConfig*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<MSKASRConfig> ice_timeout(int __timeout) const
    {
        return dynamic_cast<MSKASRConfig*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<MSKASRConfig> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<MSKASRConfig*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<MSKASRConfig> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<MSKASRConfig*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

namespace RoboCompMSKRGBD
{

class MSKRGBDEvent : virtual public ::Ice::Object
{
public:

    typedef MSKRGBDEventPrx ProxyType;
    typedef MSKRGBDEventPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void newRGBImageAvailable(const ::RoboCompMSKRGBD::TRGBImage&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___newRGBImageAvailable(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void newDepthImageAvailable(const ::RoboCompMSKRGBD::TDepthImage&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___newDepthImageAvailable(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
};

inline bool operator==(const MSKRGBDEvent& l, const MSKRGBDEvent& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const MSKRGBDEvent& l, const MSKRGBDEvent& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class MSKRGBD : virtual public ::Ice::Object
{
public:

    typedef MSKRGBDPrx ProxyType;
    typedef MSKRGBDPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void getRGBImage(::RoboCompMSKRGBD::TRGBImage&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getRGBImage(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getDepthImage(::RoboCompMSKRGBD::TDepthImage&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getDepthImage(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
};

inline bool operator==(const MSKRGBD& l, const MSKRGBD& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const MSKRGBD& l, const MSKRGBD& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

namespace RoboCompMSKBody
{

class MSKBodyEvent : virtual public ::Ice::Object
{
public:

    typedef MSKBodyEventPrx ProxyType;
    typedef MSKBodyEventPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void newMSKBodyEvent(const ::RoboCompMSKBody::PersonList&, ::Ice::Long, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___newMSKBodyEvent(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
};

inline bool operator==(const MSKBodyEvent& l, const MSKBodyEvent& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const MSKBodyEvent& l, const MSKBodyEvent& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

namespace RoboCompMSKFace
{

class MSKFaceEvent : virtual public ::Ice::Object
{
public:

    typedef MSKFaceEventPrx ProxyType;
    typedef MSKFaceEventPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void newFaceAvailable(const ::RoboCompMSKFace::DetailedFaceMap&, ::Ice::Long, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___newFaceAvailable(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
};

inline bool operator==(const MSKFaceEvent& l, const MSKFaceEvent& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const MSKFaceEvent& l, const MSKFaceEvent& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

namespace RoboCompMSKASR
{

class MSKASREvent : virtual public ::Ice::Object
{
public:

    typedef MSKASREventPrx ProxyType;
    typedef MSKASREventPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void newSentenceAvailable(const ::RoboCompMSKASR::TSentence&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___newSentenceAvailable(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
};

inline bool operator==(const MSKASREvent& l, const MSKASREvent& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const MSKASREvent& l, const MSKASREvent& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class MSKASRConfig : virtual public ::Ice::Object
{
public:

    typedef MSKASRConfigPrx ProxyType;
    typedef MSKASRConfigPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void setTestConfig(const ::RoboCompMSKASR::TestConfig&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setTestConfig(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setTestQuestion(::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setTestQuestion(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
};

inline bool operator==(const MSKASRConfig& l, const MSKASRConfig& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const MSKASRConfig& l, const MSKASRConfig& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

namespace RoboCompMSKRGBD
{

template<class T>
class CallbackNC_MSKRGBDEvent_newRGBImageAvailable : public Callback_MSKRGBDEvent_newRGBImageAvailable_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MSKRGBDEvent_newRGBImageAvailable(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_MSKRGBDEvent_newRGBImageAvailablePtr
newCallback_MSKRGBDEvent_newRGBImageAvailable(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MSKRGBDEvent_newRGBImageAvailable<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MSKRGBDEvent_newRGBImageAvailablePtr
newCallback_MSKRGBDEvent_newRGBImageAvailable(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MSKRGBDEvent_newRGBImageAvailable<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_MSKRGBDEvent_newRGBImageAvailablePtr
newCallback_MSKRGBDEvent_newRGBImageAvailable(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MSKRGBDEvent_newRGBImageAvailable<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MSKRGBDEvent_newRGBImageAvailablePtr
newCallback_MSKRGBDEvent_newRGBImageAvailable(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MSKRGBDEvent_newRGBImageAvailable<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_MSKRGBDEvent_newRGBImageAvailable : public Callback_MSKRGBDEvent_newRGBImageAvailable_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MSKRGBDEvent_newRGBImageAvailable(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_MSKRGBDEvent_newRGBImageAvailablePtr
newCallback_MSKRGBDEvent_newRGBImageAvailable(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MSKRGBDEvent_newRGBImageAvailable<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MSKRGBDEvent_newRGBImageAvailablePtr
newCallback_MSKRGBDEvent_newRGBImageAvailable(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MSKRGBDEvent_newRGBImageAvailable<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_MSKRGBDEvent_newRGBImageAvailablePtr
newCallback_MSKRGBDEvent_newRGBImageAvailable(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MSKRGBDEvent_newRGBImageAvailable<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MSKRGBDEvent_newRGBImageAvailablePtr
newCallback_MSKRGBDEvent_newRGBImageAvailable(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MSKRGBDEvent_newRGBImageAvailable<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_MSKRGBDEvent_newDepthImageAvailable : public Callback_MSKRGBDEvent_newDepthImageAvailable_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MSKRGBDEvent_newDepthImageAvailable(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_MSKRGBDEvent_newDepthImageAvailablePtr
newCallback_MSKRGBDEvent_newDepthImageAvailable(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MSKRGBDEvent_newDepthImageAvailable<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MSKRGBDEvent_newDepthImageAvailablePtr
newCallback_MSKRGBDEvent_newDepthImageAvailable(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MSKRGBDEvent_newDepthImageAvailable<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_MSKRGBDEvent_newDepthImageAvailablePtr
newCallback_MSKRGBDEvent_newDepthImageAvailable(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MSKRGBDEvent_newDepthImageAvailable<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MSKRGBDEvent_newDepthImageAvailablePtr
newCallback_MSKRGBDEvent_newDepthImageAvailable(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MSKRGBDEvent_newDepthImageAvailable<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_MSKRGBDEvent_newDepthImageAvailable : public Callback_MSKRGBDEvent_newDepthImageAvailable_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MSKRGBDEvent_newDepthImageAvailable(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_MSKRGBDEvent_newDepthImageAvailablePtr
newCallback_MSKRGBDEvent_newDepthImageAvailable(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MSKRGBDEvent_newDepthImageAvailable<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MSKRGBDEvent_newDepthImageAvailablePtr
newCallback_MSKRGBDEvent_newDepthImageAvailable(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MSKRGBDEvent_newDepthImageAvailable<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_MSKRGBDEvent_newDepthImageAvailablePtr
newCallback_MSKRGBDEvent_newDepthImageAvailable(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MSKRGBDEvent_newDepthImageAvailable<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MSKRGBDEvent_newDepthImageAvailablePtr
newCallback_MSKRGBDEvent_newDepthImageAvailable(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MSKRGBDEvent_newDepthImageAvailable<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_MSKRGBD_getRGBImage : public Callback_MSKRGBD_getRGBImage_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::RoboCompMSKRGBD::TRGBImage&);

    CallbackNC_MSKRGBD_getRGBImage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::RoboCompMSKRGBD::MSKRGBDPrx __proxy = ::RoboCompMSKRGBD::MSKRGBDPrx::uncheckedCast(__result->getProxy());
        ::RoboCompMSKRGBD::TRGBImage RGBImage;
        try
        {
            __proxy->end_getRGBImage(RGBImage, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(RGBImage);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_MSKRGBD_getRGBImagePtr
newCallback_MSKRGBD_getRGBImage(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::RoboCompMSKRGBD::TRGBImage&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MSKRGBD_getRGBImage<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MSKRGBD_getRGBImagePtr
newCallback_MSKRGBD_getRGBImage(T* instance, void (T::*cb)(const ::RoboCompMSKRGBD::TRGBImage&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MSKRGBD_getRGBImage<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_MSKRGBD_getRGBImage : public Callback_MSKRGBD_getRGBImage_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::RoboCompMSKRGBD::TRGBImage&, const CT&);

    Callback_MSKRGBD_getRGBImage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::RoboCompMSKRGBD::MSKRGBDPrx __proxy = ::RoboCompMSKRGBD::MSKRGBDPrx::uncheckedCast(__result->getProxy());
        ::RoboCompMSKRGBD::TRGBImage RGBImage;
        try
        {
            __proxy->end_getRGBImage(RGBImage, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(RGBImage, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_MSKRGBD_getRGBImagePtr
newCallback_MSKRGBD_getRGBImage(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::RoboCompMSKRGBD::TRGBImage&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MSKRGBD_getRGBImage<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MSKRGBD_getRGBImagePtr
newCallback_MSKRGBD_getRGBImage(T* instance, void (T::*cb)(const ::RoboCompMSKRGBD::TRGBImage&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MSKRGBD_getRGBImage<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_MSKRGBD_getDepthImage : public Callback_MSKRGBD_getDepthImage_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::RoboCompMSKRGBD::TDepthImage&);

    CallbackNC_MSKRGBD_getDepthImage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::RoboCompMSKRGBD::MSKRGBDPrx __proxy = ::RoboCompMSKRGBD::MSKRGBDPrx::uncheckedCast(__result->getProxy());
        ::RoboCompMSKRGBD::TDepthImage depthImage;
        try
        {
            __proxy->end_getDepthImage(depthImage, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(depthImage);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_MSKRGBD_getDepthImagePtr
newCallback_MSKRGBD_getDepthImage(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::RoboCompMSKRGBD::TDepthImage&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MSKRGBD_getDepthImage<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MSKRGBD_getDepthImagePtr
newCallback_MSKRGBD_getDepthImage(T* instance, void (T::*cb)(const ::RoboCompMSKRGBD::TDepthImage&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MSKRGBD_getDepthImage<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_MSKRGBD_getDepthImage : public Callback_MSKRGBD_getDepthImage_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::RoboCompMSKRGBD::TDepthImage&, const CT&);

    Callback_MSKRGBD_getDepthImage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::RoboCompMSKRGBD::MSKRGBDPrx __proxy = ::RoboCompMSKRGBD::MSKRGBDPrx::uncheckedCast(__result->getProxy());
        ::RoboCompMSKRGBD::TDepthImage depthImage;
        try
        {
            __proxy->end_getDepthImage(depthImage, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(depthImage, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_MSKRGBD_getDepthImagePtr
newCallback_MSKRGBD_getDepthImage(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::RoboCompMSKRGBD::TDepthImage&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MSKRGBD_getDepthImage<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MSKRGBD_getDepthImagePtr
newCallback_MSKRGBD_getDepthImage(T* instance, void (T::*cb)(const ::RoboCompMSKRGBD::TDepthImage&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MSKRGBD_getDepthImage<T, CT>(instance, cb, excb, sentcb);
}

}

namespace RoboCompMSKBody
{

template<class T>
class CallbackNC_MSKBodyEvent_newMSKBodyEvent : public Callback_MSKBodyEvent_newMSKBodyEvent_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MSKBodyEvent_newMSKBodyEvent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_MSKBodyEvent_newMSKBodyEventPtr
newCallback_MSKBodyEvent_newMSKBodyEvent(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MSKBodyEvent_newMSKBodyEvent<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MSKBodyEvent_newMSKBodyEventPtr
newCallback_MSKBodyEvent_newMSKBodyEvent(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MSKBodyEvent_newMSKBodyEvent<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_MSKBodyEvent_newMSKBodyEventPtr
newCallback_MSKBodyEvent_newMSKBodyEvent(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MSKBodyEvent_newMSKBodyEvent<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MSKBodyEvent_newMSKBodyEventPtr
newCallback_MSKBodyEvent_newMSKBodyEvent(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MSKBodyEvent_newMSKBodyEvent<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_MSKBodyEvent_newMSKBodyEvent : public Callback_MSKBodyEvent_newMSKBodyEvent_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MSKBodyEvent_newMSKBodyEvent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_MSKBodyEvent_newMSKBodyEventPtr
newCallback_MSKBodyEvent_newMSKBodyEvent(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MSKBodyEvent_newMSKBodyEvent<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MSKBodyEvent_newMSKBodyEventPtr
newCallback_MSKBodyEvent_newMSKBodyEvent(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MSKBodyEvent_newMSKBodyEvent<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_MSKBodyEvent_newMSKBodyEventPtr
newCallback_MSKBodyEvent_newMSKBodyEvent(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MSKBodyEvent_newMSKBodyEvent<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MSKBodyEvent_newMSKBodyEventPtr
newCallback_MSKBodyEvent_newMSKBodyEvent(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MSKBodyEvent_newMSKBodyEvent<T, CT>(instance, 0, excb, sentcb);
}

}

namespace RoboCompMSKFace
{

template<class T>
class CallbackNC_MSKFaceEvent_newFaceAvailable : public Callback_MSKFaceEvent_newFaceAvailable_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MSKFaceEvent_newFaceAvailable(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_MSKFaceEvent_newFaceAvailablePtr
newCallback_MSKFaceEvent_newFaceAvailable(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MSKFaceEvent_newFaceAvailable<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MSKFaceEvent_newFaceAvailablePtr
newCallback_MSKFaceEvent_newFaceAvailable(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MSKFaceEvent_newFaceAvailable<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_MSKFaceEvent_newFaceAvailablePtr
newCallback_MSKFaceEvent_newFaceAvailable(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MSKFaceEvent_newFaceAvailable<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MSKFaceEvent_newFaceAvailablePtr
newCallback_MSKFaceEvent_newFaceAvailable(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MSKFaceEvent_newFaceAvailable<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_MSKFaceEvent_newFaceAvailable : public Callback_MSKFaceEvent_newFaceAvailable_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MSKFaceEvent_newFaceAvailable(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_MSKFaceEvent_newFaceAvailablePtr
newCallback_MSKFaceEvent_newFaceAvailable(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MSKFaceEvent_newFaceAvailable<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MSKFaceEvent_newFaceAvailablePtr
newCallback_MSKFaceEvent_newFaceAvailable(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MSKFaceEvent_newFaceAvailable<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_MSKFaceEvent_newFaceAvailablePtr
newCallback_MSKFaceEvent_newFaceAvailable(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MSKFaceEvent_newFaceAvailable<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MSKFaceEvent_newFaceAvailablePtr
newCallback_MSKFaceEvent_newFaceAvailable(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MSKFaceEvent_newFaceAvailable<T, CT>(instance, 0, excb, sentcb);
}

}

namespace RoboCompMSKASR
{

template<class T>
class CallbackNC_MSKASREvent_newSentenceAvailable : public Callback_MSKASREvent_newSentenceAvailable_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MSKASREvent_newSentenceAvailable(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_MSKASREvent_newSentenceAvailablePtr
newCallback_MSKASREvent_newSentenceAvailable(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MSKASREvent_newSentenceAvailable<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MSKASREvent_newSentenceAvailablePtr
newCallback_MSKASREvent_newSentenceAvailable(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MSKASREvent_newSentenceAvailable<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_MSKASREvent_newSentenceAvailablePtr
newCallback_MSKASREvent_newSentenceAvailable(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MSKASREvent_newSentenceAvailable<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MSKASREvent_newSentenceAvailablePtr
newCallback_MSKASREvent_newSentenceAvailable(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MSKASREvent_newSentenceAvailable<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_MSKASREvent_newSentenceAvailable : public Callback_MSKASREvent_newSentenceAvailable_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MSKASREvent_newSentenceAvailable(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_MSKASREvent_newSentenceAvailablePtr
newCallback_MSKASREvent_newSentenceAvailable(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MSKASREvent_newSentenceAvailable<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MSKASREvent_newSentenceAvailablePtr
newCallback_MSKASREvent_newSentenceAvailable(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MSKASREvent_newSentenceAvailable<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_MSKASREvent_newSentenceAvailablePtr
newCallback_MSKASREvent_newSentenceAvailable(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MSKASREvent_newSentenceAvailable<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MSKASREvent_newSentenceAvailablePtr
newCallback_MSKASREvent_newSentenceAvailable(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MSKASREvent_newSentenceAvailable<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_MSKASRConfig_setTestConfig : public Callback_MSKASRConfig_setTestConfig_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MSKASRConfig_setTestConfig(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_MSKASRConfig_setTestConfigPtr
newCallback_MSKASRConfig_setTestConfig(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MSKASRConfig_setTestConfig<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MSKASRConfig_setTestConfigPtr
newCallback_MSKASRConfig_setTestConfig(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MSKASRConfig_setTestConfig<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_MSKASRConfig_setTestConfigPtr
newCallback_MSKASRConfig_setTestConfig(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MSKASRConfig_setTestConfig<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MSKASRConfig_setTestConfigPtr
newCallback_MSKASRConfig_setTestConfig(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MSKASRConfig_setTestConfig<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_MSKASRConfig_setTestConfig : public Callback_MSKASRConfig_setTestConfig_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MSKASRConfig_setTestConfig(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_MSKASRConfig_setTestConfigPtr
newCallback_MSKASRConfig_setTestConfig(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MSKASRConfig_setTestConfig<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MSKASRConfig_setTestConfigPtr
newCallback_MSKASRConfig_setTestConfig(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MSKASRConfig_setTestConfig<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_MSKASRConfig_setTestConfigPtr
newCallback_MSKASRConfig_setTestConfig(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MSKASRConfig_setTestConfig<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MSKASRConfig_setTestConfigPtr
newCallback_MSKASRConfig_setTestConfig(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MSKASRConfig_setTestConfig<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_MSKASRConfig_setTestQuestion : public Callback_MSKASRConfig_setTestQuestion_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MSKASRConfig_setTestQuestion(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_MSKASRConfig_setTestQuestionPtr
newCallback_MSKASRConfig_setTestQuestion(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MSKASRConfig_setTestQuestion<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MSKASRConfig_setTestQuestionPtr
newCallback_MSKASRConfig_setTestQuestion(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MSKASRConfig_setTestQuestion<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_MSKASRConfig_setTestQuestionPtr
newCallback_MSKASRConfig_setTestQuestion(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MSKASRConfig_setTestQuestion<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_MSKASRConfig_setTestQuestionPtr
newCallback_MSKASRConfig_setTestQuestion(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MSKASRConfig_setTestQuestion<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_MSKASRConfig_setTestQuestion : public Callback_MSKASRConfig_setTestQuestion_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MSKASRConfig_setTestQuestion(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_MSKASRConfig_setTestQuestionPtr
newCallback_MSKASRConfig_setTestQuestion(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MSKASRConfig_setTestQuestion<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MSKASRConfig_setTestQuestionPtr
newCallback_MSKASRConfig_setTestQuestion(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MSKASRConfig_setTestQuestion<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_MSKASRConfig_setTestQuestionPtr
newCallback_MSKASRConfig_setTestQuestion(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MSKASRConfig_setTestQuestion<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_MSKASRConfig_setTestQuestionPtr
newCallback_MSKASRConfig_setTestQuestion(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MSKASRConfig_setTestQuestion<T, CT>(instance, 0, excb, sentcb);
}

}

#include <IceUtil/PopDisableWarnings.h>
#endif
